<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>About on CRC - Run OpenShift 4 on your laptop</title><link>https://crc.dev/blog/</link><description>CRC - Run OpenShift 4 on your laptop (About)</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Wed, 20 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://crc.dev/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Different bundle types option in crc</title><link>https://crc.dev/blog/posts/2022-09-26-bundle-option-in-crc/</link><pubDate>Mon, 26 Sep 2022 10:41:10 +0530</pubDate><guid>https://crc.dev/blog/posts/2022-09-26-bundle-option-in-crc/</guid><description>&lt;p>CRC provides a config option called &lt;code>bundle&lt;/code> to configure the &lt;em>location&lt;/em> of the bundle,
until 2.9 release of CRC the bundle option could only accept local filesystem path
which meant users needed to download the bundle in advance before consuming it. The move to a
container registry for hosting the okd and podman bundles, introduces another step in the
process as bundles are now generated as an OCI container image and the *.crcbundle file
needs to be extracted from the image.&lt;/p>
&lt;p>Since this adds significant friction for users wanting to use different bundles, we decided
to extend the bundle config option to also support container registry urls and http/https urls
in addition to local filesystem paths.&lt;/p>
&lt;p>Starting with CRC 2.9.0 release, &lt;code>bundle&lt;/code> config option supports three different way to configure
bundle location, these are explained below with use cases.&lt;/p>
&lt;p>Case 1: If users want to use their own internal container registry for podman/okd bundles then they can
&lt;em>copy&lt;/em> the bundle images from &lt;code>quay.io&lt;/code> to their internal container registry using &lt;a href="https://github.com/containers/skopeo">skopeo&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Copy latest 4.2.0 podman bundle to internal registry&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ skopeo copy -a docker://quay.io/crcont/podman-bundle:4.2.0 docker://&amp;lt;internal_registry&amp;gt;/podman-bundle:4.2.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ crc config set bundle docker://&amp;lt;internal_registry&amp;gt;/podman-bundle:4.2.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ crc config set preset podman
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ crc setup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ crc start
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Case 2: If user tries to use the bundle which is part of internal http/https location&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ crc config set bundle https://&amp;lt;internal_server&amp;gt;/crc_libvirt_4.11.3_amd64.crcbundle
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ crc setup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ crc start
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Case 3: If a user tries to use the bundle which is downloaded locally&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ crc config set bundle &amp;lt;local_bundle_path&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ crc setup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ crc start
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As usual, we&amp;rsquo;d like to get as much &lt;a href="https://github.com/crc-org/crc/issues/new/choose">feedback&lt;/a> as possible on all this work!&lt;/p></description></item><item><title>Running OKD with CRC</title><link>https://crc.dev/blog/posts/2022-08-22-okd-on-crc/</link><pubDate>Mon, 22 Aug 2022 09:14:10 +0530</pubDate><guid>https://crc.dev/blog/posts/2022-08-22-okd-on-crc/</guid><description>&lt;p>It has been long time since CRC with an updated OKD bundle was released. Last release was &lt;a href="https://www.okd.io/crc/#get-started">1.x&lt;/a> and
not updated since then. During our 2.x development cycle, we made effort on CRC&amp;rsquo;s side to decouple the bundles from the release
artifacts. It allows us to create the bundle independently of the release and upload it to separate location.&lt;/p>
&lt;p>Another change we made during 2.x is to add support for presets and from starting we are supporting &lt;code>podman&lt;/code> and &lt;code>openshift&lt;/code>
preset with &lt;code>openshift&lt;/code> as default. With the recently released &lt;a href="https://github.com/crc-org/crc/releases/tag/v2.7.1">crc 2.7.1&lt;/a>
an &lt;code>okd&lt;/code> preset was added and users can now use same &lt;code>crc&lt;/code> binary to start a OKD cluster.&lt;/p>
&lt;p>&lt;em>A &amp;ldquo;preset&amp;rdquo; is a set of configuration parameters for the bundle to be used, the assigned memory and CPU and changes behaviour if needed for the startup process.&lt;/em>&lt;/p>
&lt;h1 id="how-it-works" >How it works
&lt;span>
&lt;a href="#how-it-works">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h1>&lt;p>The CRC team created the OKD bundle for &lt;a href="https://github.com/openshift/okd/releases/tag/4.11.0-0.okd-2022-07-29-154152">4.11.0-0.okd-2022-07-29-154152&lt;/a> release
and pushed it as container image to &lt;a href="https://quay.io/repository/crcont/okd-bundle">quay&lt;/a>. With the &lt;code>okd&lt;/code> preset, the user is now able to
run an OKD cluster locally similar to OCP.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ crc config set preset okd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Changes to configuration property &lt;span style="color:#e6db74">&amp;#39;preset&amp;#39;&lt;/span> are only applied when the CRC instance is created.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>If you already have a running CRC instance with different preset, &lt;span style="color:#66d9ef">then&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> this configuration change to take effect, delete the CRC instance with &lt;span style="color:#e6db74">&amp;#39;crc delete&amp;#39;&lt;/span>, setup it with &lt;span style="color:#e6db74">`&lt;/span>crc setup&lt;span style="color:#e6db74">`&lt;/span> and start it with &lt;span style="color:#e6db74">&amp;#39;crc start&amp;#39;&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ crc config view
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- consent-telemetry : yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- preset : okd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ crc setup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>...&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INFO Checking &lt;span style="color:#66d9ef">if&lt;/span> /Users/prkumar/.crc/cache/crc_okd_vfkit_4.11.0-0.okd-2022-07-29-154152_arm64.crcbundle exists
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INFO Getting bundle &lt;span style="color:#66d9ef">for&lt;/span> the CRC executable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INFO Downloading crc_okd_vfkit_4.11.0-0.okd-2022-07-29-154152_arm64.crcbundle
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>...&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ crc start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>...&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="where-were-at" >Where we&amp;rsquo;re at
&lt;span>
&lt;a href="#where-were-at">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h1>&lt;ul>
&lt;li>Update the CRC related pages on OKD&lt;/li>
&lt;li>Put CI in place to create OKD bundles for each release and upload it to quay.&lt;/li>
&lt;li>Coordinate with OKD community to interact with users.&lt;/li>
&lt;/ul>
&lt;p>As usual, we&amp;rsquo;d like to get as much &lt;a href="https://github.com/crc-org/crc/issues/new/choose">feedback&lt;/a> as possible on all this work!&lt;/p></description></item><item><title>Running ocp on M1 machines</title><link>https://crc.dev/blog/posts/2022-08-17-ocp-on-m1/</link><pubDate>Wed, 17 Aug 2022 08:58:10 +0530</pubDate><guid>https://crc.dev/blog/posts/2022-08-17-ocp-on-m1/</guid><description>&lt;p>With the release of CRC 2.4.1 it was possible to run on Apple&amp;rsquo;s latest offering of M1-based machines.
However, the support was limited to podman preset. Numerous times we received requests if it would be
possible to instead offer an OpenShift that would run on these machines. This has changed with the recently released &lt;a href="https://github.com/crc-org/crc/releases/tag/v2.7.1">crc 2.7.1&lt;/a>.
This blog post will describe the challenges we had to overcome when we decided to add that support.&lt;/p>
&lt;h1 id="background" >Background
&lt;span>
&lt;a href="#background">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h1>&lt;p>CRC is a tool that manages the lifecycle of a virtual machine and allows you to run an OpenShift cluster or podman containers on a laptop or local workstation.
It can be used on a macOS, Windows or Linux machine.
It runs its OpenShift cluster/podman runtime using a disk image built in advance and packaged in what we call a &lt;em>bundle&lt;/em>.
On each platform, we try to use native hypervisors, such as KVM on Linux, Hyper-V on Windows, and using the virtualization framework on macOS.&lt;/p>
&lt;h1 id="issue-of-running-ocp-on-m1" >Issue of running OCP on M1
&lt;span>
&lt;a href="#issue-of-running-ocp-on-m1">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h1>&lt;p>Openshift container platform (OCP) uses Red Hat Core OS (RHCOS) which is based on latest RHEL-8 which is
compiled for a 64K page size, but Apple M1 processor uses 4K or a maximum size of 16K page sizes &lt;a href="https://access.redhat.com/discussions/5966451">link&lt;/a>.&lt;/p>
&lt;h1 id="how-it-works" >How it works
&lt;span>
&lt;a href="#how-it-works">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h1>&lt;p>After we provision the Openshift cluster we replaced the RHEL-8 kernel packages to RHEL-9 which doesn&amp;rsquo;t have issue to boot on
Apple M1 machines. Using this kernel it is possible to workaround this issue, and we are able to run the created disk image on M1.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ rpm -qa | grep kernel
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kernel-5.14.0-70.13.1.el9_0.aarch64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kernel-core-5.14.0-70.13.1.el9_0.aarch64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kernel-modules-extra-5.14.0-70.13.1.el9_0.aarch64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kernel-modules-5.14.0-70.13.1.el9_0.aarch64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="where-were-at" >Where we&amp;rsquo;re at
&lt;span>
&lt;a href="#where-were-at">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h1>&lt;p>Once RHCOS switches to RHEL-9, we don&amp;rsquo;t need to replace the kernel bits manually and this workaround can be removed.&lt;/p>
&lt;p>As usual, we&amp;rsquo;d like to get as much &lt;a href="https://github.com/crc-org/crc/issues/new/choose">feedback&lt;/a> as possible on all this work!&lt;/p></description></item><item><title>Running crc on M1 machines</title><link>https://crc.dev/blog/posts/2022-06-15-vfkit/</link><pubDate>Wed, 15 Jun 2022 16:08:10 +0200</pubDate><guid>https://crc.dev/blog/posts/2022-06-15-vfkit/</guid><description>&lt;p>Since its initial release, CRC has been running on macOS as well as on Windows and Linux.
However macOS support was limited to Apple machines with an Intel CPUs until recently.
With Apple&amp;rsquo;s ongoing switch to aarch64 M1 CPUs, we&amp;rsquo;ve been asked numerous times when CRC would get M1 support.
This has changed with the recently released &lt;a href="https://github.com/crc-org/crc/releases/tag/v2.4.1">crc 2.4.1&lt;/a>.
This blog post will describe the challenges we had to overcome when we decided to add that support.&lt;/p>
&lt;h1 id="background" >Background
&lt;span>
&lt;a href="#background">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h1>&lt;p>CRC is a tool which allows you to run an OpenShift cluster or podman containers on a laptop or local workstation.
It can be used on a macOS, Windows or Linux machine.
It runs its OpenShift cluster/podman runtime by starting a virtual machine (VM) using a disk image built in advance and packaged in what we call a &lt;em>bundle&lt;/em>.
On each platform, we try to use native hypervisors.&lt;/p>
&lt;p>On macOS, crc uses &lt;a href="https://github.com/moby/hyperkit">hyperkit&lt;/a> as its
hypervisor. It has served us well over the years, but lately it hasn&amp;rsquo;t seen a
lot of maintainance, and we&amp;rsquo;ve been hitting a few annoying bugs in its &lt;a href="https://github.com/mirage/ocaml-qcow">ocaml
qcow2 implementation&lt;/a>.&lt;/p>
&lt;p>However, the main problem with hyperkit is that it&amp;rsquo;s x86_64 only. It does not
provide any M1 support, so we had to look for alternatives if we want to run
CRC on a M1 mac.&lt;/p>
&lt;h1 id="qemu-and-virtualizationframework" >QEMU and virtualization.framework
&lt;span>
&lt;a href="#qemu-and-virtualizationframework">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h1>&lt;p>When looking for hypervisors we could use on macOS, we found two candidates:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.qemu.org/">QEMU&lt;/a> with its &lt;a href="https://wiki.qemu.org/Features/HVF">hvf acceleration&lt;/a>&lt;/li>
&lt;li>Apple&amp;rsquo;s own &lt;a href="https://developer.apple.com/documentation/virtualization">virtualization framework&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="qemu" >QEMU
&lt;span>
&lt;a href="#qemu">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>QEMU is a widely used hypervisor on Linux systems, but it can also be used on
Windows and macOS. On macOS, it can use Apple&amp;rsquo;s &lt;a href="https://developer.apple.com/documentation/hypervisor">hypervisor
framework&lt;/a> to make use of
virtualization support in hardware.
It has a huge range of features. In particular it supports many virtio devices including &lt;a href="https://virtio-fs.gitlab.io/">virtiofs&lt;/a> for file sharing,
Its main drawback is that for supply chain trust reasons, we&amp;rsquo;d have to maintain
our own QEMU builds, which can be quite an endeavour given the size of QEMU&amp;rsquo;s
code base (2 million lines of C code).&lt;/p>
&lt;h2 id="apples-virtualization-framework" >Apple&amp;rsquo;s virtualization framework
&lt;span>
&lt;a href="#apples-virtualization-framework">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>This is a &lt;a href="https://developer.apple.com/documentation/virtualization">high level Objective-C/swift framework&lt;/a> to start virtual machines on Apple hardware with a small set of virtio devices (disk, network, &amp;hellip;).
It was introduced in macOS &amp;lsquo;Big Sur&amp;rsquo; 11.0, and only supports macOS and Linux virtual machines. Luckily, our bundle is a Linux image, so it&amp;rsquo;s good enough for us!
It obviously supports both x86_64 and M1 CPUs.&lt;/p>
&lt;p>Its main advantage and drawback is that it&amp;rsquo;s a high-level framework maintained by Apple. This means very little code is needed to create a virtual machine with it, and Apple maintains and updates all the low-level virtualization code for us.
This is also a drawback, as this framework is closed source. This means we fully depend on Apple for fixing any bugs that we might find. And unfortunately, we&amp;rsquo;ve already hit such bugs in Apple&amp;rsquo;s implementation of virtiofs, a &lt;a href="https://developer.apple.com/bug-reporting/">bug has been filed&lt;/a>, but we have no control over when it will get fixed, if ever.&lt;/p>
&lt;h1 id="introducing-vfkit" >Introducing vfkit
&lt;span>
&lt;a href="#introducing-vfkit">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h1>&lt;p>Apple&amp;rsquo;s virtualization framework looks promising, but it&amp;rsquo;s just a framework. A framework is similar to a shared library on Linux, your code can link to it to use what it offers, but you can&amp;rsquo;t directly use it as a commandline or GUI tool.
One particular caveat with the virtualization framework is that any virtual machines you start with it will only stay alive as long as the process which started it is alive.&lt;/p>
&lt;p>We could not find any pre-existing FOSS commandline tool to manage virtual machines with Apple&amp;rsquo;s virtualization framework, but luckily for us, there are &lt;a href="https://github.com/Code-Hex/vz">go bindings for it&lt;/a>.
This allowed us to write a small commandline wrapper using these bindings which we called &lt;a href="https://github.com/crc-org/vfkit">&lt;code>vfkit&lt;/code>&lt;/a>
It does not cover all features exposed by &lt;code>Code-Hex/vz&lt;/code> and the virtualization framework, but we can expand this over time. At the moment, its commandline is enough for CRC&amp;rsquo;s needs, including support for both system and usermode networking.&lt;/p>
&lt;h1 id="where-were-at" >Where we&amp;rsquo;re at
&lt;span>
&lt;a href="#where-were-at">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h1>&lt;p>With &lt;code>vfkit&lt;/code>, we have a way of starting virtual machines on M1 hardware. The second thing that we need is a bundle with the appropriate disk images. The two main changes we had to do were:&lt;/p>
&lt;ul>
&lt;li>move from qcow2 to raw disk images as this is the only format Apple&amp;rsquo;s virtualization framework supports. This meant modifying CRC to make use of &lt;a href="https://en.wikipedia.org/wiki/Sparse_file">sparse files&lt;/a> as much as possible to minimize disk usage. The &lt;a href="https://www.manpagez.com/man/2/clonefile/">&lt;code>clonefile&lt;/code>&lt;/a> system call was also very handy to limit the amount of disk space that we use&lt;/li>
&lt;li>the &lt;a href="https://www.kernel.org/doc/Documentation/arm64/booting.txt">aarch64 kernel &lt;strong>must&lt;/strong> be uncompressed&lt;/a>, otherwise the virtual machine won&amp;rsquo;t start. This is fairly tedious to figure out as you don&amp;rsquo;t get any output from the virtual machine to let you know what went wrong.&lt;/li>
&lt;/ul>
&lt;p>After these changes, we were able to generate a podman bundle to use natively on a M1 machine. As its x86_64 counterpart, this bundle is built on top of Fedora CoreOS.
Running OpenShift on a M1 CPU won&amp;rsquo;t be possible soon, as it&amp;rsquo;s currently based on Red Hat CoreOS 8, and &lt;a href="https://access.redhat.com/solutions/6545411">its kernel is incompatible with M1 CPUs&lt;/a>.&lt;/p>
&lt;p>&lt;code>vfkit&lt;/code> support for x86_64 hardware landed in crc 2.3.0 release, and so far did not have many issues reported.
We merged M1 vfkit support in crc 2.4.1, but had last minute issues related to signing, so it&amp;rsquo;s only available as an &lt;a href="https://github.com/crc-org/crc/releases/download/v2.4.1/crc-macos-unsigned-arm64.pkg">unsigned installer&lt;/a> for this release. Hopefully this will be solved in time for crc 2.5.&lt;/p>
&lt;p>Once this is finalized, we still have plenty to explore in vfkit and M1 support: file sharing support, OKD bundles, microshift bundles, &amp;hellip; so stay tuned!&lt;/p>
&lt;p>As usual, we&amp;rsquo;d like to get as much &lt;a href="https://github.com/crc-org/crc/issues/new/choose">feedback&lt;/a> as possible on all this work!&lt;/p></description></item><item><title>About</title><link>https://crc.dev/blog/about/</link><pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate><guid>https://crc.dev/blog/about/</guid><description>&lt;p>CRC brings a minimal OpenShift Container Platform 4 cluster and Podman container runtime to your local computer. These runtimes provide minimal environments for development and testing purposes. CRC is mainly targeted at running on developers&amp;rsquo; desktops. For other OpenShift Container Platform use cases, such as headless or multi-developer setups, use the &lt;a href="https://console.redhat.com/openshift/install">full OpenShift installer&lt;/a>.&lt;/p>
&lt;p>See the &lt;a href="https://docs.openshift.com/container-platform/latest/welcome/index.html#developer-activities">OpenShift documentation&lt;/a> for a full introduction to OpenShift Container Platform.&lt;/p>
&lt;p>CRC includes the crc command-line interface (CLI) to interact with the CRC instance using the desired container runtime.&lt;/p>
&lt;p>Learn more and contribute on &lt;a href="https://github.com/crc-org/crc">GitHub&lt;/a>.&lt;/p></description></item></channel></rss>